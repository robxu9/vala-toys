diff --git a/afrodite/ast.vala b/afrodite/ast.vala
index 22cc449..854c642 100644
--- a/afrodite/ast.vala
+++ b/afrodite/ast.vala
@@ -27,7 +27,14 @@ namespace Afrodite
 	public class Ast
 	{
 		private Symbol _root = new Symbol (null, null);
-		
+
+		~Ast()
+		{
+			Utils.trace ("ast destroy");
+			_root.destroy ();
+			_root = null;
+		}
+
 		public Symbol root {
 			get { return _root; }
 			set { _root = value; }
diff --git a/afrodite/astmerger.vala b/afrodite/astmerger.vala
index ce89ec5..8b3a2df 100644
--- a/afrodite/astmerger.vala
+++ b/afrodite/astmerger.vala
@@ -71,8 +71,9 @@ namespace Afrodite
 			}
 			if (source.has_symbols) {
 				foreach (Symbol symbol in source.symbols) {
-					if (remove_symbol (source, symbol))
+					if (remove_symbol (source, symbol)) {
 						symbol.destroy ();
+					}
 				}
 				source.symbols = null;
 			}
@@ -94,6 +95,7 @@ namespace Afrodite
 			}
 
 			// leave glib symbols, or symbols with references in other source files
+			
 			if (symbol.has_children) {
 				Vala.List<Symbol> to_del = new Vala.ArrayList<Symbol> ();
 				
@@ -104,10 +106,12 @@ namespace Afrodite
 				}
 				
 				foreach (Symbol child in to_del) {
-					symbol.remove_child (child);
+					child.destroy ();
+					//symbol.remove_child (child);
 				}
 			}
 			
+
 			if (orphaned) {
 				// the symbol should be deleted since there aren't any source ref
 				if (symbol.has_children && symbol.type_name == "Namespace") {
diff --git a/afrodite/completionengine.vala b/afrodite/completionengine.vala
index 6a49555..29891fa 100644
--- a/afrodite/completionengine.vala
+++ b/afrodite/completionengine.vala
@@ -64,6 +64,7 @@ namespace Afrodite
 		
 		~Completion ()
 		{
+			Utils.trace ("completion %s destroy", id);
 			// invalidate the ast so the parser thread will exit asap
 			_ast_mutex.lock ();
 			_ast = null;
diff --git a/afrodite/datatype.vala b/afrodite/datatype.vala
index f870e45..6dd591f 100644
--- a/afrodite/datatype.vala
+++ b/afrodite/datatype.vala
@@ -49,6 +49,15 @@ namespace Afrodite
 			this.type_name = type_name;
 		}
 
+		~DataType ()
+		{
+			if (generic_types != null) {
+				generic_types.clear ();
+				generic_types = null;
+			}
+			source_reference = null;
+		}
+
 		public string type_name
 		{
 			get {
@@ -226,5 +235,6 @@ namespace Afrodite
 			res.source_reference = source_reference;
 			return res;
 		}
+
 	}
 }
diff --git a/afrodite/sourcefile.vala b/afrodite/sourcefile.vala
index 0f69318..759181b 100644
--- a/afrodite/sourcefile.vala
+++ b/afrodite/sourcefile.vala
@@ -26,6 +26,8 @@ namespace Afrodite
 {
 	public class SourceFile
 	{
+		public static Vala.List<unowned Symbol> remains = new Vala.ArrayList<unowned Symbol>();
+		
 		public Vala.List<DataType> using_directives { get; set; }
 		public Vala.List<Symbol> symbols { get; set; }
 		
@@ -37,7 +39,22 @@ namespace Afrodite
 		{
 			this.filename = filename;
 		}
-		
+
+		~SourceFile ()
+		{
+			Utils.trace ("SourceFile destroyed: %s", filename);
+			if (has_symbols) {
+				while(symbols.size > 0) {
+					var symbol = symbols.get (0);
+					symbols.remove (symbol);
+					symbol.destroy();
+					if (symbol.ref_count > 1)
+						Utils.trace ("refcount dump symbol %s: %u", symbol.fully_qualified_name, symbol.ref_count);
+					symbol = null;
+				}
+			}
+		}
+
 		public DataType add_using_directive (string name)
 		{
 			var u = lookup_using_directive (name);
@@ -86,9 +103,50 @@ namespace Afrodite
 			if (symbols == null) {
 				symbols = new ArrayList<Symbol> ();
 			}
+			
+			if (symbols.contains (symbol)) {
+				GLib.error ("adding the same symbol %s twice: %s", this._filename, symbol.fully_qualified_name);
+			}
+			
 			symbols.add (symbol);
+			
+			remains.add (symbol);
+			symbol.add_toggle_ref (this.on_symbol_orphan);
 		}
-		
+
+		private void on_symbol_orphan (Object obj, bool is_last_ref)
+		{
+			if (is_last_ref) {
+				int prev = remains.size;
+				remains.remove ((Symbol)obj);
+				Utils.trace ("obj destroyed %s (%p) prev count: %d total: %d", ((Symbol) obj).fully_qualified_name, obj, prev, remains.size);
+				if (((Symbol)obj).fully_qualified_name == "GLib.qsort_with_data")
+					breakpoint ();
+				obj.remove_toggle_ref (this.on_symbol_destroyed);
+				
+				if (remains.size < 60)
+					dump_leaks ();
+			}
+		}
+
+		private void dump_leaks ()
+		{
+			foreach (Symbol s in remains) {
+				Utils.trace ("symbol %s (%p), parent %s (%p), generic_parent %s (%p) childs %d",
+					s.fully_qualified_name, s,
+					s.parent == null ? "null" : s.parent.fully_qualified_name, s.parent,
+					s.generic_parent == null ? "null" : s.generic_parent.fully_qualified_name, s.generic_parent,
+					s.has_children ? s.children.size : 0);
+			}
+		}
+		private void on_symbol_destroyed (Object obj)
+		{
+			int prev = remains.size;
+			remains.remove ((Symbol)obj);
+			
+			Utils.trace ("obj destroyed prev count: %d total: %d", prev, remains.size);
+		}
+
 		public void remove_symbol (Symbol symbol)
 		{
 			symbols.remove (symbol);
diff --git a/afrodite/symbol.vala b/afrodite/symbol.vala
index dc26f4a..d1734e8 100644
--- a/afrodite/symbol.vala
+++ b/afrodite/symbol.vala
@@ -28,11 +28,18 @@ namespace Afrodite
 	{
 		public static VoidType VOID = new VoidType ();
 		public static EllipsisType ELLIPSIS = new EllipsisType ();
-		
-		public unowned Symbol parent { get; set; }
+		private unowned Symbol _parent;
+		public unowned Symbol parent { get { return _parent; } 
+			set {
+				_parent = value;
+				if (this.fully_qualified_name == "UnicodeScript") {
+					Utils.trace ("UnicodeScript parent: %s", _parent == null ? "null" : _parent.fully_qualified_name);
+				}
+			}
+		}
 		public Vala.List<Symbol> children { get; set; }
 		public Vala.List<Symbol> resolve_targets = null; // contains a reference to symbols of whose this symbol is a resolved reference for any target data type
-		public unowned Symbol? generic_parent { get; set; }
+		public Symbol? generic_parent { get; set; }
 		
 		public string name { get; set; }
 		public string fully_qualified_name { get; set; }
@@ -92,14 +99,15 @@ namespace Afrodite
 				_symbol_type = Afrodite.Utils.Symbols.get_predefined ().signal_type;
 			}
 		}
-		
+
 		~Symbol ()
 		{
-			if (_specialized_symbols != null) {
-				_specialized_symbols.clear ();
-				_specialized_symbols = null;
-			}
+//			Utils.trace ("Symbol destroying: %s (%p)", fully_qualified_name, this);
+			
+			if (_fully_qualified_name != null && _fully_qualified_name.has_prefix ("GLib.Parameter.value"))
+				Utils.trace ("Symbol destroyed.: %s (%p)", fully_qualified_name, this);
 		}
+
 		public int static_child_count
 		{
 			get {
@@ -132,6 +140,11 @@ namespace Afrodite
 				children = new ArrayList<Symbol> ();
 			}
 
+			if (child == this)
+				error ("circular reference: %s", this.fully_qualified_name);
+
+			if (children.contains (child))
+				error ("duplicte reference: %s in %s", child.fully_qualified_name, this.fully_qualified_name);
 			children.add (child);
 			child.parent = this;
 			if (child.is_static || child.has_static_child) {
@@ -144,7 +157,14 @@ namespace Afrodite
 		
 		public void remove_child (Symbol child)
 		{
+			if (!children.contains(child))
+				error ("child %s doesn't exists in %s: %p", child.fully_qualified_name, _fully_qualified_name, this);
+
+			if (child.parent == this)
+				child.parent = null;
+
 			children.remove (child);
+
 			if (children.size == 0)
 				children = null;
 				
@@ -270,7 +290,15 @@ namespace Afrodite
 				if (resolve_targets == null) {
 					resolve_targets = new ArrayList<Symbol> ();
 				}
-				resolve_targets.add (resolve_target);
+
+				if (resolve_target == this)
+					error ("circular reference: %s", this.fully_qualified_name);
+
+				if (resolve_target.fully_qualified_name == "GLib.Parameter.value") {
+					Utils.trace ("adding %s to %s", resolve_target.fully_qualified_name, fully_qualified_name);
+				}
+				if (!resolve_targets.contains (resolve_target))
+					resolve_targets.add (resolve_target);
 			}
 		}
 		
@@ -327,6 +355,12 @@ namespace Afrodite
 			}
 			
 			//debug ("added generic %s to %s", sym.name, this.fully_qualified_name);
+			
+			if (sym == this)
+				error ("circular reference: %s", this.fully_qualified_name);
+
+			if (generic_type_arguments.contains (sym))
+				error ("duplicte reference: %s in %s", sym.fully_qualified_name, this.fully_qualified_name);
 			generic_type_arguments.add (sym);
 		}
 		
@@ -480,40 +514,139 @@ namespace Afrodite
 		 */
 		public void destroy ()
 		{
+			unlink (this);
+
+			this.generic_parent = null;
+
 			if (has_children) {
-				//remove_child (_children.get (0));
+				foreach (var child in children)
+					child.parent = null;
+
 				_children.clear ();
 				_children = null;
 			}
 
-			while (has_resolve_targets) {
-				var target = resolve_targets.get (0);
-				// remove from return type
-				if (target.return_type != null && target.return_type.symbol == this) {
-					target.return_type.symbol = null;
+			if (has_resolve_targets) {
+				lock (resolve_targets) {
+					resolve_targets.clear ();
 				}
-				// remove from parameters
-				if (target.has_parameters) {
-					foreach (DataType type in target.parameters) {
-						if (type.symbol == this) {
-							type.symbol = null;
-						}
+				resolve_targets = null;
+			}
+
+			if (this.has_generic_type_arguments) {
+				generic_type_arguments.clear ();
+				generic_type_arguments = null;
+			}
+
+			if (this.has_specialized_symbols) {
+				_specialized_symbols.clear ();
+				_specialized_symbols = null;
+			}
+
+			this.return_type = null;
+
+			if (this.has_parameters) {
+				this.parameters.clear ();
+				this.parameters = null;
+			}
+
+			if (this.has_local_variables) {
+				this.local_variables.clear ();
+				this.local_variables = null;
+			}
+
+			if (this.has_base_types) {
+				this.base_types.clear ();
+				this.base_types = null;
+			}
+
+			_symbol_type = null;
+			this.parent = null;
+		}
+
+		internal void unlink (Symbol symbol)
+		{
+			if (symbol.generic_parent == null && symbol.parent != null && symbol.parent.has_children) {
+				symbol.parent.remove_child (symbol);
+			}
+
+			symbol.parent = null;
+
+			if (symbol.generic_parent != null && symbol.generic_parent.has_specialized_symbols) {
+				symbol.generic_parent.remove_specialized_symbol (symbol);
+			}
+
+			symbol.generic_parent = null;
+	
+			if (this.has_children) {
+				//remove_child (_children.get (0));
+				foreach (var child in _children) {
+					child.unlink (symbol);
+				}
+			}
+
+			if (this.has_resolve_targets) {
+				foreach (var target in this.resolve_targets) {
+					if (target != symbol)
+						target.unlink (symbol);
+				}
+			}
+
+			if (this.has_generic_type_arguments) {
+				foreach (var arg in generic_type_arguments) {
+					if (arg != symbol)
+						arg.unlink (symbol);
+				}
+			}
+
+			if (this.has_specialized_symbols) {
+				foreach (var sym in _specialized_symbols) {
+					if (sym != symbol)
+						sym.unlink (symbol);
+				}
+			}
+
+			// set all the datatype unresolved if required
+			if (this.return_type != null && this.return_type.symbol == symbol)
+				this.return_type.symbol = null;
+
+			if (this.has_parameters) {
+				foreach (DataType type in parameters) {
+					if (type.symbol == symbol)
+						type.symbol = null;
+					else if (!type.unresolved && type.symbol.has_resolve_targets) {
+						type.symbol.remove_resolve_target (symbol);
 					}
 				}
+			}
 
-				// remove from local_variables
-				if (target.has_local_variables) {
-					foreach (DataType type in target.local_variables) {
-						if (type.symbol == this) {
-							type.symbol = null;
-						}
+			if (this.has_local_variables) {
+				foreach (DataType type in local_variables) {
+					if (type.symbol == symbol)
+						type.symbol = null;
+					else if (!type.unresolved && type.symbol.has_resolve_targets) {
+						type.symbol.remove_resolve_target (symbol);
 					}
 				}
-				remove_resolve_target (target);
 			}
-			
-			if (parent != null && parent.has_children) {
-				parent.remove_child (this);
+
+			if (this.has_base_types) {
+				foreach (DataType type in this.base_types) {
+					if (type.symbol == symbol)
+						type.symbol = null;
+					else if (!type.unresolved && type.symbol.has_resolve_targets) {
+						type.symbol.remove_resolve_target (symbol);
+					}
+				}
+			}
+
+			if (_symbol_type != null) {
+				if (!_symbol_type.unresolved && _symbol_type.symbol.has_resolve_targets) {
+					_symbol_type.symbol.remove_resolve_target (symbol);
+				}
+				if (_symbol_type.symbol == symbol) {
+					_symbol_type.symbol = null;
+				}
 			}
 		}
 
@@ -807,6 +940,9 @@ namespace Afrodite
 
 		public Symbol copy ()
 		{
+			if (_fully_qualified_name == "RhythmPnP.MediaLibraryDevice.cleanup") {
+				breakpoint();
+			}
 			var res = new Symbol (_fully_qualified_name, type_name);
 			res.type_name = this.type_name;
 			res.parent = this.parent;
@@ -893,10 +1029,40 @@ namespace Afrodite
 			if (_specialized_symbols == null)
 				_specialized_symbols = new Vala.ArrayList<Symbol> ();
 
+			if (item == this)
+				error ("circular reference: %s", this.fully_qualified_name);
+
+			if (_specialized_symbols.contains (item))
+				error ("duplicate reference: %s in %s", item.fully_qualified_name, this.fully_qualified_name);
+
 			_specialized_symbols.add (item);
 			item.generic_parent = this;
 		}
 
+		public void remove_specialized_symbol (Symbol? item)
+		{
+			if (item == this)
+				error ("circular reference: %s", this.fully_qualified_name);
+
+			if (!_specialized_symbols.contains (item))
+				error ("symbol doesn't belong to this: %s in %s", item.fully_qualified_name, this.fully_qualified_name);
+
+			_specialized_symbols.remove (item);
+
+			if (item.generic_parent == this)
+				item.generic_parent = null;
+
+			if (_specialized_symbols.size == 0)
+				_specialized_symbols = null;
+		}
+
+		public bool has_specialized_symbols 
+		{
+			get {
+				return _specialized_symbols != null;
+			}
+		}
+
 		private void resolve_generic_type (Symbol symbol, string generic_type_name, DataType type)
 		{
 			if (symbol.return_type != null) {
diff --git a/afrodite/symbolresolver.vala b/afrodite/symbolresolver.vala
index 5bec1ed..f79afe6 100644
--- a/afrodite/symbolresolver.vala
+++ b/afrodite/symbolresolver.vala
@@ -67,7 +67,7 @@ namespace Afrodite
 			if (res == null && symbol.has_children) {
 				
 				var s = Ast.lookup_symbol (type.type_name, symbol, ref parent, Afrodite.CompareMode.EXACT);
-				if (s != null) {
+				if (s != null && s != symbol) {
 					res = s;
 				}
 			}
@@ -82,7 +82,7 @@ namespace Afrodite
 				for (int i = 0; i < names.length; i++) {
 					string name = names[i];
 					var s = curr_parent.lookup_child (name);
-					if (s != null) {
+					if (s != null && s != symbol) {
 						if (i == names.length -1) {
 							res = s; // last name part: symbol found
 						}
@@ -95,7 +95,7 @@ namespace Afrodite
 						if (curr_parent.has_local_variables) {
 							foreach (var item in curr_parent.local_variables) {
 								//Utils.trace ("localvar %s: %s vs %s:%s unresolved %d", item.name, item.type_name, type.name, type.type_name, (int) type.unresolved);
-								if (!item.unresolved && item.name == name) {
+								if (!item.unresolved && item.name == name && item.symbol != symbol) {
 									type.type_name = item.type_name;
 									res = item.symbol;
 									break;
@@ -106,7 +106,7 @@ namespace Afrodite
 						if (curr_parent.has_parameters) {
 							foreach (var item in curr_parent.parameters) {
 								//Utils.trace ("parameter %s: %s vs %s:%s unresolved %d", item.name, item.type_name, type.name, type.type_name, (int) type.unresolved);
-								if (!item.unresolved && item.name == name) {
+								if (!item.unresolved && item.name == name && item.symbol != symbol) {
 									type.type_name = item.type_name;
 									res = item.symbol;
 									break;
@@ -146,7 +146,8 @@ namespace Afrodite
 									break; // file.using_directives
 								}
 							}
-							res = s;
+							if (s != symbol)
+								res = s;
 							
 							if (res != null) {
 								break;
@@ -178,14 +179,17 @@ namespace Afrodite
 					}
 				}
 
-				res.add_resolve_target (symbol);
+				if (res != Symbol.VOID)
+					res.add_resolve_target (symbol);
 			}
+
 			return res;
 		}
 
 		private Symbol specialize_generic_symbol (DataType type, Symbol symbol)
 		{
 			var c = symbol.copy();
+
 			visit_symbol (c);
 			c.specialize_generic_symbol (type.generic_types);
 			visit_symbol (c);
@@ -209,6 +213,7 @@ namespace Afrodite
 				}
 			}
 			symbol.add_specialized_symbol (c);
+
 			return c;
 		}
 
diff --git a/afrodite/utils.vala b/afrodite/utils.vala
index db7f00a..07f519f 100644
--- a/afrodite/utils.vala
+++ b/afrodite/utils.vala
@@ -100,6 +100,9 @@ namespace Afrodite.Utils
 
 		context.add_package (pkg);
 
+		return true;
+		
+		breakpoint ();
 		foreach (string package_path in packages) {
 			Utils.trace ("adding package %s: %s", pkg, package_path);
 			context.add_source_file (new Vala.SourceFile (context, package_path, true));
diff --git a/vbf/vbfpackage.vala b/vbf/vbfpackage.vala
index 80f9104..fb4bde8 100644
--- a/vbf/vbfpackage.vala
+++ b/vbf/vbfpackage.vala
@@ -62,7 +62,7 @@ namespace Vbf
 				int i = 0;
 				foreach (string vapi_dir in parent_target.get_include_dirs ()) {
 					vapi_dirs[i] = vapi_dir + "/";
-					Utils.trace ("**** adding vapidir: %s", vapi_dir);
+					Utils.trace ("**** adding search vapidir: %s", vapi_dir);
 					i++;
 				}
 			}
diff --git a/vtg/vtgprojectmanager.vala b/vtg/vtgprojectmanager.vala
index b28f27e..727e0cc 100644
--- a/vtg/vtgprojectmanager.vala
+++ b/vtg/vtgprojectmanager.vala
@@ -82,6 +82,7 @@ namespace Vtg
 		
 		~ProjectManager ()
 		{
+			Utils.trace ("ProjectManager destroy");
 			cleanup_completions ();
 		}
 
@@ -287,6 +288,7 @@ namespace Vtg
 					_completions.@set (target, completion);
 
 					foreach(string path in target.get_include_dirs ()) {
+						Utils.trace ("completion adding vapidir: %s", path);
 						completion.add_vapi_dir (path);
 					}
 
diff --git a/vtg/vtgprojects.vala b/vtg/vtgprojects.vala
index 4328be9..bc46f3d 100644
--- a/vtg/vtgprojects.vala
+++ b/vtg/vtgprojects.vala
@@ -28,7 +28,7 @@ using Vbf;
 
 namespace Vtg
 {
-	public class Projects : GLib.Object	
+	public class Projects : GLib.Object
 	{
 		private unowned Plugin _plugin;
 		
diff --git a/vtg/vtgprojectview.vala b/vtg/vtgprojectview.vala
index 503150f..29040c5 100644
--- a/vtg/vtgprojectview.vala
+++ b/vtg/vtgprojectview.vala
@@ -84,7 +84,7 @@ namespace Vtg
 	 					if (_current_project.model != null) {
 	 						update_project_treeview ();
 						} else {
-							_prj_view.set_model (null);
+							clear_project_treeview ();
 						}
 
 						//sync the project combo view
@@ -92,7 +92,7 @@ namespace Vtg
 						if (this.lookup_iter_for_project_name (_current_project.project.name, out iter))
 							_prjs_combo.set_active_iter (iter);
 					} else {
-						_prj_view.set_model (null);
+						clear_project_treeview ();
 					}
 				}
 			}
@@ -179,7 +179,13 @@ namespace Vtg
 			_prj_view.set_model (_filtered_model);
 			_prj_view.expand_all ();
 		}
-		
+
+		private void clear_project_treeview ()
+		{
+			_prj_view.set_model (null);
+			_filtered_model = null;
+		}
+
 		private bool filter_function (Gtk.TreeModel sender, Gtk.TreeIter iter)
 		{
 			bool res = true;
@@ -233,6 +239,8 @@ namespace Vtg
 					Project selected_project;
 					_prjs_model.get (iter, 1, out selected_project);
 					update_view (selected_project.name);
+				} else {
+					update_view (null);
 				}
 			} else {
 				update_view (null);
